{-|
Problem: <https://adventofcode.com/2020/day/11>

Solution:

General - Seat System. Main problem to solve is to be able to
to check the rules for a given seat. What is the best data
structure for that? Options are ...

* 2-dim array of seat status
* map of coordinates to status
* list of x,y,status triplets

Operations we need on this data structure are ...

* lookup status
* change status (not really, because we always build a new map)

We always need two maps, because we need a/the old (unchanged/
unmodified) map to build the new map (because the status changes
everywhere at the same time).

It would be cool, if (while we build the new/next map) we could
also determine the neighbor count right away, but ... that is not
possible (because the descison if a seat is occupied is made using
the old/previous map).

But ... we can first build the new map and then build a helper map,
where every cell has a/the neighbor count in it.

We can then start to do a recursion until the next map is the same
as the previous map.

Part 1 - ???

Part 2 - ???
-}
module Day11 where

import Prelude

import Data.List (init, (!!))
import Data.String (lines)
import Data.Binary (toStr)
import Data.Map as M

data Status = Floor | Empty | Occupied | Unknown
type Location = (Integer, Integer)
type Seats = M.Map Location Status
type SeatsNeighbors = M.Map Location Integer 

input :: String -> Seats
input filename = M.fromList seats where
    contents = init $ lines $ toStr $ unsafePerformIO $ readFile filename
    rCount = length contents
    cCount = length $ contents !! 0
    rows = zip [0 .. (rCount - 1)] contents
    grid = map (\(row, cols) -> (row, zip [0 .. (cCount - 1)] cols)) rows
    seats = foldl (++) [] $ map (\(row, cols) -> map (\(col, status) -> ((row, col), makeStatus status)) cols) grid where
        makeStatus '.' = Floor
        makeStatus 'L' = Empty
        makeStatus _ = Unknown

part1 :: Seats -> Integer
part1 seats = M.size seats

part2 :: Seats -> Integer
part2 seats = M.size seats
